<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Our 3D Heart Space</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <style>
        :root { --rose-gold: #b76e79; --gold: #d4af37; }
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
            touch-action: none; 
            -webkit-user-select: none; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
        }
        
        #ui-container {
            position: absolute;
            top: 60px; width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            color: var(--gold);
        }
        .title { font-size: 24px; font-weight: 200; letter-spacing: 6px; text-shadow: 0 0 10px rgba(212,175,55,0.4); }
        
        #video-container { 
            position: fixed; 
            bottom: 20px; 
            right: 20px; 
            width: 80px; 
            height: 60px; 
            opacity: 0.2; 
            border: 1px solid var(--gold); 
            border-radius: 8px; 
            overflow: hidden; 
            transform: scaleX(-1); 
            z-index: 50;
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        #gesture-hint {
            position: absolute;
            bottom: 40px; width: 100%;
            text-align: center;
            color: #fff; opacity: 0.4;
            font-size: 10px;
            letter-spacing: 1px;
            z-index: 5;
        }

        #loader {
            position: fixed; inset: 0; background: #000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: var(--gold);
        }
        
        #start-btn {
            margin-top: 30px;
            padding: 10px 30px;
            background: transparent;
            border: 1px solid var(--gold);
            color: var(--gold);
            border-radius: 20px;
            cursor: pointer;
        }

        #gesture-feedback {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            padding: 5px 15px; border-radius: 20px; background: rgba(0,0,0,0.5);
            color: var(--gold); font-size: 12px; border: 1px solid var(--gold);
            opacity: 0; transition: opacity 0.3s; z-index: 20;
        }
    </style>
</head>
<body>

<div id="loader">
    <div style="font-size: 30px; margin-bottom: 20px;">ğŸ“·</div>
    <div id="loader-status">æ­£åœ¨é«˜æ¸…åŒ–ç…§ç‰‡ç©ºé—´...</div>
    <button id="start-btn" style="display:none;">å¼€å¯é«˜æ¸…ä½“éªŒ</button>
</div>

<div id="gesture-feedback">å‡†å¤‡ä¸­</div>

<div id="ui-container">
    <div class="title">MEMORIES SPACE</div>
    <div style="font-size: 10px; margin-top: 5px; opacity: 0.5;">ğŸ–ï¸ ç¼©æ”¾ | âœŠ æ”¶å› | â†”ï¸ æ»‘åŠ¨æ—‹è½¬</div>
</div>

<div id="video-container">
    <video id="webcam" playsinline muted autoplay></video>
</div>

<div id="gesture-hint">å·¦å³æ»‘åŠ¨å±å¹•å¯æ‰‹åŠ¨æ—‹è½¬è§†è§’</div>

<div id="canvas-container"></div>

<script>
    let scene, camera, renderer, particles, photos = [];
    let currentExplodeFactor = 0;
    let targetExplodeFactor = 0;
    let autoRotationY = 0;
    let userRotationY = 0;
    let isTouching = false;
    let lastTouchX = 0;
    let handX = 0; // æ‰‹éƒ¨åœ¨å±å¹•ä¸Šçš„åç§»

    const photoUrls = [
        '1.jpg', 
        '2.jpg',
        '3.jpg', 
        '4.jpg',
        '5.jpg', 
        '6.jpg',
        '7.jpg', 
        '8.jpg',
        '9.jpg', 
        '10.jpg',
        '11.jpg',
        '12.jpg', 
        '13.jpg',
        '14.jpg', 
        '15.jpg',
        '16.jpg', 
        '17.jpg',
        '18.jpg', 
        '19.jpg',
        '20.jpg', 
        '21.jpg',
        '22.jpg', 
        '23.jpg',
        '24.jpg', 
        '25.jpg',
        '26.jpg', 
        '27.jpg',
        '28.jpg', 
        '29.jpg',
        '30.jpg', 
        '31.jpg', 
        '32.jpg', 
        '34.jpg',
        '35.jpg',
        '36.jpg',
        '37.jpg',
        '38.jpg',
        '39.jpg',
        '40.jpg',
        '41.jpg',
        '42.jpg',
        '43.jpg',
        '44.jpg',
        '45.jpg',
        '46.jpg',
        '47.jpg',
        '48.jpg',
        '49.jpg',
        '50.jpg',
        '51.jpg',
        '52.jpg',
        '53.jpg',
        '54.jpg',
        '55.jpg',
        '56.jpg',
        '57.jpg',
        '58.jpg',
        '59.jpg',
        '60.jpg',
        '61.jpg',
        '62.jpg',
        '63.jpg',
        '64.jpg',
        '65.jpg',
        '66.jpg',
        '67.jpg',
        '68.jpg',
        '69.jpg',
        '70.jpg',
        '71.jpg',
        '72.jpg',
    ];

    const COUNT = 30;

    function initScene() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 55;

        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio); // æ¢å¤é«˜æ¸…åƒç´ æ¯”
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.2));

        // åŸºç¡€ç²’å­
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<1000; i++) {
            starPos.push((Math.random()-0.5)*300, (Math.random()-0.5)*300, (Math.random()-0.5)*300);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        particles = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xaaaaaa, size: 0.3}));
        scene.add(particles);

        const getHeart = (t) => {
            return new THREE.Vector3(
                16 * Math.pow(Math.sin(t), 3),
                13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t),
                0
            ).multiplyScalar(1.2);
        };

        const textureLoader = new THREE.TextureLoader();
        for(let i=0; i<COUNT; i++){
            const t = (i/COUNT) * Math.PI * 2;
            const pos = getHeart(t);
            const geo = new THREE.BoxGeometry(4, 5.2, 0.1);
            
            // åŠ è½½çº¹ç†å¹¶è®¾ç½®é«˜æ¸…è¿‡æ»¤
            const texture = textureLoader.load(photoUrls[i % photoUrls.length], (tex) => {
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            });

            const mats = [
                new THREE.MeshBasicMaterial({color: 0xb76e79}), 
                new THREE.MeshBasicMaterial({color: 0xb76e79}), 
                new THREE.MeshBasicMaterial({color: 0xb76e79}), 
                new THREE.MeshBasicMaterial({color: 0xb76e79}), 
                new THREE.MeshBasicMaterial({map: texture}), 
                new THREE.MeshBasicMaterial({color: 0x000000})  
            ];
            const mesh = new THREE.Mesh(geo, mats);
            mesh.position.copy(pos);
            mesh.lookAt(0,0,10);
            
            photos.push({ 
                mesh, 
                homePos: pos.clone(), 
                homeRot: mesh.rotation.clone(), 
                // å¢åŠ éšæœºæ€§è®©åˆ’è¿‡å±å¹•çš„æ„Ÿè§‰æ›´è‡ªç„¶
                targetPos: new THREE.Vector3((Math.random()-0.5)*150, (Math.random()-0.5)*150, (Math.random()-0.5)*100),
                targetRot: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI),
                driftOffset: Math.random() * 20
            });
            scene.add(mesh);
        }

        // äº¤äº’ç›‘å¬ï¼šæ‰‹åŠ¨æ—‹è½¬
        window.addEventListener('mousedown', (e) => { isTouching = true; lastTouchX = e.clientX; });
        window.addEventListener('mousemove', (e) => {
            if(isTouching) {
                const deltaX = e.clientX - lastTouchX;
                userRotationY += deltaX * 0.01;
                lastTouchX = e.clientX;
            }
        });
        window.addEventListener('mouseup', () => isTouching = false);
        window.addEventListener('touchstart', (e) => { isTouching = true; lastTouchX = e.touches[0].clientX; });
        window.addEventListener('touchmove', (e) => {
            if(isTouching) {
                const deltaX = e.touches[0].clientX - lastTouchX;
                userRotationY += deltaX * 0.01;
                lastTouchX = e.touches[0].clientX;
            }
        });
        window.addEventListener('touchend', () => isTouching = false);

        document.getElementById('loader-status').innerText = "å·²å°±ç»ª";
        document.getElementById('start-btn').style.display = "block";
        animate();
    }

    document.getElementById('start-btn').onclick = async function() {
        try { await navigator.mediaDevices.getUserMedia({ video: true }); } catch (err) {}
        await setupAI();
        document.getElementById('loader').style.display = 'none';
    };

    async function setupAI() {
        const video = document.getElementById('webcam');
        const feedback = document.getElementById('gesture-feedback');

        try {
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
            
            hands.onResults(res => {
                if(res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                    const lm = res.multiHandLandmarks[0];
                    const dist = Math.hypot(lm[12].x - lm[0].x, lm[12].y - lm[0].y);
                    
                    // è®°å½•æ‰‹éƒ¨æ°´å¹³ä½ç½®ï¼Œç”¨äºæ§åˆ¶ç…§ç‰‡â€œåˆ’è¿‡â€
                    handX = (lm[0].x - 0.5) * 60; 

                    feedback.style.opacity = "1";
                    let factor = (dist - 0.28) / (0.52 - 0.28);
                    factor = Math.max(0, Math.min(1, factor));
                    if(dist < 0.26) factor = 0;
                    
                    targetExplodeFactor = factor;
                    feedback.innerText = factor > 0.1 ? "ğŸ–ï¸ æ­£åœ¨ç»½æ”¾" : "âœŠ æ¡ç´§å®ˆæŠ¤";
                } else {
                    feedback.style.opacity = "0";
                }
            });

            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 480, height: 360
            });
            await cam.start();
        } catch (e) { console.error(e); }
    }

    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();

        currentExplodeFactor += (targetExplodeFactor - currentExplodeFactor) * 0.1;
        
        // è‡ªåŠ¨æ—‹è½¬åŸºç¡€é‡
        autoRotationY += 0.002;

        photos.forEach(p => {
            // ä½ç½®ï¼šç»“åˆçˆ†ç‚¸ç³»æ•°å’Œæ‰‹éƒ¨å®æ—¶æ°´å¹³ä½ç½®ï¼Œå®ç°â€œåˆ’è¿‡å±å¹•â€æ„Ÿ
            const driftX = handX * currentExplodeFactor;
            p.mesh.position.lerpVectors(p.homePos, p.targetPos, currentExplodeFactor);
            p.mesh.position.x += driftX; 

            // æ—‹è½¬ï¼šæ‰‹åŠ¨æ—‹è½¬ + è‡ªåŠ¨æ—‹è½¬ + çˆ†ç‚¸åçš„ä¹±åºæ—‹è½¬
            p.mesh.rotation.x = p.homeRot.x + (p.targetRot.x - p.homeRot.x) * currentExplodeFactor;
            p.mesh.rotation.z = p.homeRot.z + (p.targetRot.z - p.homeRot.z) * currentExplodeFactor;
            
            // æ¯ä¸€ä¸ªç…§ç‰‡éƒ½åœ¨è‡ªå·±çš„ Y è½´ä¸Šå—æ§äºå…¨å±€æ—‹è½¬
            p.mesh.rotation.y = p.homeRot.y + (p.targetRot.y - p.homeRot.y) * currentExplodeFactor + (userRotationY + autoRotationY);
        });

        // æ•´ä¸ªç²’å­èƒŒæ™¯ä¹Ÿè·Ÿéšæ—‹è½¬
        particles.rotation.y = (userRotationY + autoRotationY) * 0.5;

        renderer.render(scene, camera);
    }

    window.onresize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };

    window.onload = initScene;
</script>
</body>
</html>
