<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Our 3D Heart Space</title>
    <!-- æ ¸å¿ƒ 3D åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    
    <!-- MediaPipe AI åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <style>
        :root { --rose-gold: #b76e79; --gold: #d4af37; }
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; -webkit-user-select: none; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        
        #ui-container {
            position: absolute;
            top: 60px; width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            color: var(--gold);
        }
        .title { font-size: 24px; font-weight: 200; letter-spacing: 6px; text-shadow: 0 0 15px rgba(212,175,55,0.6); }
        
        /* éšè—è§†é¢‘æµä½†ä¿æŒè¿è¡Œ */
        #video-container { position: fixed; bottom: 10px; right: 10px; width: 80px; height: 60px; opacity: 0.3; border: 1px solid var(--gold); border-radius: 8px; overflow: hidden; transform: scaleX(-1); display: none; }
        video { width: 100%; height: 100%; object-fit: cover; }

        #gesture-hint {
            position: absolute;
            bottom: 40px; width: 100%;
            text-align: center;
            color: #fff; opacity: 0.5;
            font-size: 11px;
            letter-spacing: 1px;
            z-index: 5;
        }

        #loader {
            position: fixed; inset: 0; background: #020205;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: var(--gold);
            padding: 20px;
            text-align: center;
        }
        .pulse-heart {
            font-size: 48px; animation: pulse 1.2s infinite ease-in-out; margin-bottom: 20px;
        }
        @keyframes pulse { 0% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.15); opacity: 1; } 100% { transform: scale(1); opacity: 0.8; } }
        
        #start-btn {
            margin-top: 30px;
            padding: 12px 35px;
            background: transparent;
            border: 1px solid var(--gold);
            color: var(--gold);
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            -webkit-appearance: none;
        }

        /* æ‰‹åŠ¿åé¦ˆå…‰åœˆ */
        #gesture-feedback {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            padding: 5px 15px; border-radius: 20px; background: rgba(212,175,55,0.2);
            color: var(--gold); font-size: 12px; border: 1px solid var(--gold);
            opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 20;
        }
    </style>
</head>
<body>

<div id="loader">
    <div class="pulse-heart">âœ¨â¤ï¸âœ¨</div>
    <div id="loader-status">æ­£åœ¨åˆå§‹åŒ– AI è‰ºæœ¯ç©ºé—´...</div>
    <button id="start-btn" style="display:none;">å¼€å¯ç©ºé—´</button>
</div>

<div id="gesture-feedback">æ£€æµ‹åˆ°æ‰‹åŠ¿</div>

<div id="ui-container">
    <div class="title">MEMORIES SPACE</div>
    <div style="font-size: 11px; opacity: 0.6; margin-top: 8px;">è®©æ€å¿µè·¨è¶Šæ˜Ÿè¾°</div>
</div>

<div id="video-container">
    <video id="webcam" playsinline muted></video>
</div>

<div id="gesture-hint">ğŸ–ï¸ äº”æŒ‡å¼ å¼€çˆ†ç‚¸ | âœŠ æ¡æ‹³èšåˆ<br>ğŸ“± å€¾æ–œæ‰‹æœºäº’åŠ¨ | ğŸ‘† ç‚¹å‡»å±å¹•</div>

<div id="canvas-container"></div>

<script>
    let scene, camera, renderer, particles, photos = [];
    let isExploded = false;
    let coreLight;
    let targetRot = { x: 0, y: 0 };
    let handsAI;

    const photoUrls = [
        '1.jpg', 
        '2.jpg',
        '3.jpg', 
        '4.jpg',
        '5.jpg', 
        '6.jpg',
        '7.jpg', 
        '8.jpg',
        '9.jpg', 
        '10.jpg',
        '11.jpg', 
        '12.jpg',
        '13.jpg', 
        '14.jpg',
        '15.jpg', 
        '16.jpg',
        '17.jpg', 
        '18.jpg',
        '19.jpg', 
        '20.jpg',
        '21.jpg', 
        '22.jpg',
        '23.jpg', 
        '24.jpg',
        '25.jpg', 
        '26.jpg',
        '27.jpg', 
        '28.jpg',
    ];

    const COUNT = 34; 

    function initScene() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 55;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        coreLight = new THREE.PointLight(0xffb6c1, 2.5, 60);
        scene.add(coreLight);

        // æ˜Ÿç©ºèƒŒæ™¯
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<1500; i++) {
            starPos.push((Math.random()-0.5)*250, (Math.random()-0.5)*250, (Math.random()-0.5)*250);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        particles = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.4, transparent: true, opacity: 0.6}));
        scene.add(particles);

        const getHeart = (t) => {
            return new THREE.Vector3(
                16 * Math.pow(Math.sin(t), 3),
                13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t),
                0
            ).multiplyScalar(1.2);
        };

        const textureLoader = new THREE.TextureLoader();

        for(let i=0; i<COUNT; i++){
            const t = (i/COUNT) * Math.PI * 2;
            const pos = getHeart(t);
            const geo = new THREE.BoxGeometry(4, 5.2, 0.3);
            
            const texture = textureLoader.load(photoUrls[i % photoUrls.length]);
            const mats = [
                new THREE.MeshStandardMaterial({color: 0xb76e79, metalness: 0.8}), 
                new THREE.MeshStandardMaterial({color: 0xb76e79, metalness: 0.8}), 
                new THREE.MeshStandardMaterial({color: 0xb76e79, metalness: 0.8}), 
                new THREE.MeshStandardMaterial({color: 0xb76e79, metalness: 0.8}), 
                new THREE.MeshStandardMaterial({map: texture}), 
                new THREE.MeshStandardMaterial({color: 0x050505})  
            ];
            const mesh = new THREE.Mesh(geo, mats);
            mesh.position.copy(pos);
            mesh.lookAt(0,0,10);
            photos.push({ mesh, homePos: pos.clone(), homeRot: mesh.rotation.clone(), v: new THREE.Vector3() });
            scene.add(mesh);
        }

        document.getElementById('loader-status').innerText = "èµ„æºå·²å°±ç»ªï¼Œå»ºè®®åœ¨å…‰çº¿å……è¶³å¤„ä½¿ç”¨";
        document.getElementById('start-btn').style.display = "block";
        animate();
    }

    document.getElementById('start-btn').onclick = async function() {
        this.innerText = "è¯·æ±‚æƒé™ä¸­...";
        
        // å°è¯•å¯åŠ¨é™€èºä»ª
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try { await DeviceOrientationEvent.requestPermission(); } catch (e) {}
        }

        window.addEventListener('deviceorientation', e => {
            if(e.gamma !== null) {
                targetRot.y = (e.gamma / 45);
                targetRot.x = (e.beta / 45 - 1.5);
            }
        });

        // å°è¯•å¯åŠ¨ç›¸æœºå’Œ AI
        await setupAI();
        
        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
    };

    async function setupAI() {
        const video = document.getElementById('webcam');
        const feedback = document.getElementById('gesture-feedback');

        try {
            handsAI = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            handsAI.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5, // é™ä½é˜ˆå€¼ä»¥æé«˜è¯†åˆ«ç‡
                minTrackingConfidence: 0.5
            });
            
            handsAI.onResults(res => {
                if(res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                    const lm = res.multiHandLandmarks[0];
                    
                    // æ ¸å¿ƒé€»è¾‘ï¼šè®¡ç®—æŒ‡å°–åˆ°æŒå¿ƒçš„å¹³å‡è·ç¦»
                    // lm[0] æ˜¯æ‰‹è…•, lm[12] æ˜¯ä¸­æŒ‡å°–
                    const dist = Math.hypot(lm[12].x - lm[0].x, lm[12].y - lm[0].y);
                    
                    // æ˜¾ç¤ºæ‰‹åŠ¿åé¦ˆ
                    feedback.style.opacity = "1";
                    
                    if(dist > 0.4) {
                        feedback.innerText = "ğŸ–ï¸ çˆ†ç‚¸";
                        if(!isExploded) explode();
                    } else if(dist < 0.25) {
                        feedback.innerText = "âœŠ å›æ”¶";
                        if(isExploded) contract();
                    }
                } else {
                    feedback.style.opacity = "0";
                }
            });

            const cam = new Camera(video, {
                onFrame: async () => { await handsAI.send({image: video}); },
                width: 480, height: 640
            });
            
            await cam.start();
            document.getElementById('video-container').style.display = 'block';
        } catch (e) {
            console.error("AI å¯åŠ¨å¤±è´¥ï¼Œå°†ä»…æ”¯æŒç‚¹å‡»äº¤äº’:", e);
        }
    }

    function explode() {
        if (isExploded) return;
        isExploded = true;
        photos.forEach(p => {
            const dest = new THREE.Vector3((Math.random()-0.5)*130, (Math.random()-0.5)*130, (Math.random()-0.5)*90);
            new TWEEN.Tween(p.mesh.position).to(dest, 1600).easing(TWEEN.Easing.Exponential.Out).start();
            new TWEEN.Tween(p.mesh.rotation).to({x: Math.random()*8, y: Math.random()*8, z: Math.random()*8}, 1600).start();
            p.v.set((Math.random()-0.5)*0.12, (Math.random()-0.5)*0.12, (Math.random()-0.5)*0.12);
        });
    }

    function contract() {
        if (!isExploded) return;
        isExploded = false;
        photos.forEach(p => {
            new TWEEN.Tween(p.mesh.position).to(p.homePos, 1300).easing(TWEEN.Easing.Cubic.InOut).start();
            new TWEEN.Tween(p.mesh.rotation).to(p.homeRot, 1300).easing(TWEEN.Easing.Cubic.InOut).start();
            p.v.set(0,0,0);
        });
    }

    window.addEventListener('touchstart', (e) => {
        if (document.getElementById('loader').style.display === 'none') {
            isExploded ? contract() : explode();
        }
    });

    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        const t = Date.now() * 0.001;

        if(!isExploded) {
            const s = 1 + Math.sin(t*2.8)*0.025;
            scene.scale.set(s,s,s);
        } else {
            photos.forEach(p => {
                p.mesh.position.add(p.v);
                p.mesh.rotation.y += 0.004;
            });
        }

        camera.position.x += (targetRot.y * 22 - camera.position.x) * 0.06;
        camera.position.y += (-targetRot.x * 22 - camera.position.y) * 0.06;
        camera.lookAt(0,0,0);
        
        particles.rotation.y += 0.0008;
        coreLight.intensity = 2.5 + Math.sin(t*3.5);
        renderer.render(scene, camera);
    }

    window.onresize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };

    window.onload = initScene;
</script>
</body>
</html>

